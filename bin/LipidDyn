#!/usr/bin/env python


# Copyright (C) 2019, Simone Scrima <simonescrima@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program. If not, see <http://www.gnu.org/licenses/>.


import time
import errno
import subprocess
import sys
import os
import os.path as path
import argparse
import shutil
from pathlib import Path
import glob
import pandas as pd
from progressbar import ProgressBar
import numpy as np

#Import the classes and functions from the utils
from LipidDyn.core import *

# Import pkg management library
import pkg_resources

#Import MDanalysis
import MDAnalysis as mda
from MDAnalysis.analysis.leaflet import LeafletFinder




def module_thickness(universe,
                     membrane,
                     protein,
                     directory_name,
                     cutoff,
                     raw,
                     ncore
                     ):
        
    """Fuction consisting of thickness analysis 
    Thickness (raw +xvg)

    Parameters
    ----------
    universe : class 
        MDAnalysis universe class
    directory_name : str
            Name of the output folder
    cutoff : float
            Number representing the cut-off for the thickness
    raw : True/False
            Value to include or not the raw output
    ncore : int
            Number of cores for parallelization             
    """
    
    # Output directory
    analysis_thickness = os.path.abspath(directory_name + '/Thickness/')
    if not os.path.exists(analysis_thickness):
        try:
            os.mkdir((analysis_thickness))
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise

    
    # Begins of the fatslim analysis 
    thickness = Thickness(universe,
                          membrane,
                          protein,
                          ncore,
                          cutoff,
                          raw,
                          analysis_thickness)

    # Execute Fatslim commands
    df = thickness.run(out_file = 'thickness.xvg')
    df.to_csv(os.path.join(analysis_thickness,'thickness.csv'),
                           index=False)
    return(df)




def module_apl(universe,
               membrane,
               protein,
               directory_name,
               cutoff,
               raw,
               ncore
               ):
    
    """Fuction consisting of apl analysis 
    1) APL (raw+xvg)

    Parameters
    ----------
    universe : class 
        MDAnalysis universe class
    directory_name : str
            Name of the output folder
    cutoff : float
            Number representing the cut-off for the APL
    raw : True/False
            Value to include or not the raw output
    ncore : int
            Number of cores for parallelization             
    """

 
    # Output directory
    analysis_apl = os.path.abspath(directory_name + '/Apl/')
    if not os.path.exists(analysis_apl):
        try:
            os.mkdir((analysis_apl))
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise

    
    # Begins of the fatslim analysis 
    apl = AreaPerLipid(universe,
                       membrane,
                       protein,
                       ncore,
                       cutoff,
                       raw,
                       analysis_apl)

    # Execute Fatslim commands
    df = apl.run(out_file ='apl.xvg')
    df.to_csv(os.path.join(analysis_apl,'apl.csv'),
                           index=False)
    return(df)


    
def module_densmap(universe,
                   leaflets,
                   directory_name):

    """
    Parameters
    -------------
    universe : class 
        MDAnalysis universe class
    leaflets : dict 
        Dictionary with MDAnalysis AtomGroup as keys of all
        the lipid residues in upper and lower leaflet. 
        Obtained using LeafletFinder class in MDAnalysis
    ncore : int
        Number of cores for parallelization        
    directory_name : str
        Name of the output folder
    """

    # output directory
    folder = os.path.abspath(directory_name +'/2D_maps/')
    if not os.path.exists(folder):
        try:
            os.mkdir((folder))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise
    
    u = universe
    for leaflet in leaflets:
        # compute density maps for each leaflet
        dmap = Density(u)
        grid = dmap.run(leaflets[leaflet].residues.atoms)
        np.savetxt(os.path.join(folder ,leaflet +"_2dmap.dat"),
                   grid,
                   delimiter='\t',
                   fmt='%1.4f')
  

def module_enrichment(universe,
                      selection,
                      leaflets,
                      directory_name):
    """
    Parameters
    -------------
    universe : class 
        MDAnalysis universe class
    selection : dict 
        MDAnalysis AtomGroup selection of all the
        lipid residue constituting the lipid bilayer
    ncore : int
        Number of cores for parallelization        
    directory_name : str
        Name of the output folder
    """

    # output directory
    folder = os.path.abspath(directory_name +'/Enrichment/')
    if not os.path.exists(folder):
        try:
            os.mkdir((folder))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise
    
    # Run the enrichment analysis for the entire membrane
    enr = Enrichment(universe)
    d = enr.run(selection)
  
    # Write Output
    for lipid in d:
        np.savetxt(os.path.join(folder,lipid+"_enrich.dat"),
                    d[lipid],
                    delimiter='\t',
                    fmt='%1.4f') 
    
    # Repeat for both leaflets
    for leaflet in leaflets:
        d1 = enr.run(leaflets[leaflet])
        for lipid in d1:
            np.savetxt(os.path.join(folder,lipid+"_"+leaflet+"_enrich.dat"),
                       d1[lipid],
                       delimiter='\t',
                       fmt='%1.4f') 




def module_movements(universe,
                     leaflets,
                     directory_name):
         
    # Creates different folder in which the output is stored

    """From the imported module uses these function to extract the 
    trajectories associated with each lipids of both upper and lower 
    leaflet

    Parameters
    ----------
    universe : obj
            Universe object from MDAnalysis library
    leaflets : dict
        Dictionary with MDAnalysis AtomGroup as keys of all
        the lipid residues in upper and lower leaflet. 
        Obtained using LeafletFinder class in MDAnalysis
    directory_name : str
            Name of the output folder
    """

    # output directory
    analysis_traj = os.path.abspath(directory_name + "/Diffusion_movements/")
    if not os.path.exists(analysis_traj):
        try:
            os.mkdir((analysis_traj))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise
    
    # initialize class
    m = Movement(universe)
   
    # iterate through the dictionary
    for leaflet in leaflets:
        # compute 
        df = m.run(leaflets[leaflet])
        # select name
        if leaflet == "upper_leaflet": 
            filename = "u_leaflet_coordinates.csv"
        else:
            filename = "l_leaflet_coordinates.csv"
        
        # Save output
        df.to_csv(os.path.join(analysis_traj,filename))



def module_order_parameter(universe,
                           selection,
                           directory_name
                           ):
    
    """
    Parameters
    ----------
    universe: obj
            Universe object from MDAnalysis library
    selection : obj
        MDAnalysis AtomGroup selection of all the
        lipid residue constituting the lipid bilayer
    directory_name : str
            Name of the output folder
    """
    
    
    # Creates different folder in which the output is stored

    order_folder = directory_name + '/Order_Parameter/'

    if not os.path.exists(order_folder):
        try:
            os.mkdir((order_folder))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise


    # find lipid species
    lipids = list(np.unique(selection.residues.resnames))

    # retrieve def file for the op in the package folder
    dirs =  pkg_resources.resource_listdir('LipidDyn',
                                           '/definitions_files/')
    
    for def_file in dirs:
        ordPars = OrderedDict()
        # get the lipid name
        lipid_name = def_file.split('.')[0]
        
        # compute OP only for available species
        if lipid_name not in lipids:
            continue
        else: 
            # retrieve the def files from the package
            defi = pkg_resources.resource_string('LipidDyn',
                                    '/definitions_files/'+ def_file)
            # decode the strings from bytes
            defi = defi.decode("utf-8").split('\n') 
            # filter empty strings
            defi = list(filter(lambda x: x != '', defi)) 
            
            # Parse file and call OrderParameter class
            for line in defi:
                if not line.startswith("#"):
                    items = line.split()
                    ordPars[items[0]] = OrderParameter(*items)
            
            # Select atoms for OP calculations
            for op in ordPars.values():
            # selection = pairs of atoms, split-by residues
            # this selection format preserves the order of the atoms (atA, atB)
            # independent of their order in the topology
                selection = universe.select_atoms(
                            "resname {rnm} and name {atA}".format(
                               rnm=op.resname, atA=op.atAname),
                               "resname {rnm} and name {atB}".format(
                               rnm=op.resname, atB=op.atBname)
                               ).atoms.split("residue")

                op.selection = selection


            # Go through trajectory frame-by-frame
            # and calculate each OP from the list of OPs
            # for each residue separately
            for frame in universe.trajectory:
                for op in ordPars.values():
        
                    # temporary list of order parameters for 
                    # each individual residue for the given frame
                    temp_S = []
                    
                    for residue in op.selection:
                        if "vec" in op.name:
                            S = op.calc_angle(residue, 
                                              z_dim=frame.dimensions[2])
                        else:
                            S = op.calc_OP(residue)
                        temp_S.append(S)

                    # resulting S-trajectory will be a list of lists
                    # so that individual residues can be easily distinquished
                    op.traj.append(temp_S)

            # Retrieve averaged data
            for op in ordPars.values():
                (op.avg, op.std, op.stem) = op.get_avg_std_stem_OP
        
     
            # writes the output file in csv format 
            try:
                filename = os.path.join(order_folder,
                          'OP_'+ lipid_name +'.csv')
         
                with open(filename,'w') as f:
                    f.write("{},{},{},{},{},{},{}  \n".format(
                    'OP_name','resname','atom1','atom2','OP_mean',
                    'OP_stddev','OP_stem'))
                    for op in ordPars.values():
                        # output in csv file format comma separated
                        f.write( 
                        "{},{},{},{},{: 2.5f},{: 2.5f},{: 2.5f} \n".format(
                                op.name, op.resname, op.atAname,
                                op.atBname,op.avg, op.std, op.stem)
                                )
            except:
                sys.stdout.write("Problem writing the main outputfile")
        
        



def main():

    description= 'LipidDyn pipeline for calculating different parameters' \
                 'of a lipid membrane Molecular Dynamics simulation'

    usage = 'LypidDyn -t ["".xtc/trr] -f ["".gro/tpr] -all [True/False] ' \
            '-c -fatslim -2d -mov -ordpar -d [directory name] -raw[True/False]'
             

    parser = argparse.ArgumentParser(description=description, usage=usage)

    parser.add_argument('-t',
                        '--trajectory',
                        dest='trajectory',
                        type=str,
                        required=True,
                        metavar='',
                        help='Trajectory files [<.xtc/.trr/>] ',
                        )

    parser.add_argument('-f',
                        '--topology',
                        dest='topology',
                        type=str,
                        required=True,
                        metavar='',
                        help='Molecular topology file [.gro/.tpr]',
                        )


    parser.add_argument('-d',
                        '--dir_name',
                        default = 'Analysis',
                        dest='directory',
                        type=str,
                        required=False,
                        metavar='',
                        help='The directory name for outputs of the pipeline',
                        )

    parser.add_argument('-c',
                        '--clean',
                        action='store_true',
                        dest='clean',
                        required = False,
                        help='Clean all the temporary files '
                        )

    parser.add_argument('-all',
                        '--all',
                        dest='all_modules',
                        action='store_true',
                        required = False,
                        help='Execute all module of the pipeline'
                        )

    parser.add_argument('-tck',
                        '--thickness',
                        action='store_true',
                        dest='mod_tck',
                        required = False,
                        help='Execute only the thickness analysis'
                        )

    parser.add_argument('-apl',
                        '--AreaPerLipid',
                        action='store_true',
                        dest='mod_apl',
                        required = False,
                        help='Execute only the area per lipid analysis'
                        )

    parser.add_argument('-apl_cutoff',
                        '--apl-cutoff',
                        default= 3.0,
                        dest='apl_cutoff',
                        required = False,
                        help='Cutoff distance (in nm) used to approximate \
                              planar region (default: 3.0)'
                        )

    parser.add_argument('-thickness_cutoff',
                        '--thickness-cutoff',
                        default= 6.0,
                        dest='tck_cutoff',
                        required = False,
                        help='Cutoff distance (in nm) used to identify \
                              inter-leaflet neighbors (default: 6.0)'
                        )

    parser.add_argument('-2d',
                        '--2d_maps',
                        action='store_true',
                        dest='mod_maps', 
                        required = False,
                        help='Execute only the density maps module of the \
                              pipeline'
                                                )

    parser.add_argument('-mov',
                        '--movements',
                        action='store_true',
                        dest='mod_mov',
                        required = False,
                        help='Execute only the movement module of the \
                              pipeline'
                       )

    parser.add_argument('-ordpar',
                        '--order_parameter',
                        action='store_true',
                        dest='mod_ord',
                        required = False,
                        help='Execute only the order parameter module of \
                              the pipeline'
                        )

    parser.add_argument('-enr',
                        '--enrichment',
                        action='store_true',
                        dest='enrichment',
                        required = False,
                        help='Execute only the enrichment analysis module \
                              of the pipeline'
                       )


    parser.add_argument('-ncore',
                        '--mpi',
                        nargs ='?',
                        default = 2,
                        dest='mpi',
                        help='Specify on how many cores to use for \
                              parallelization'
                       )

    parser.add_argument('-raw',
                        '--raw_data',
                        action='store_true',
                        dest='raw',
                        required = False,
                        help='Get the raw value of thickness and apl for \
                              each frame'
                       )




    args = parser.parse_args()

    if args is None:
        sys.stdout.write("Are you sure you followed the instruction? \
               Please follow them and retry")
        quit()
    else:
        
        traj = os.path.abspath(args.trajectory)
        topol = os.path.abspath(args.topology)
        dir_name = args.directory
        ncore = int(args.mpi)
        cleaning = args.clean
        apl_cutoff = float(args.apl_cutoff)
        tck_cutoff = float(args.tck_cutoff)
        raw = args.raw
        
        
        starting_directory = os.getcwd()

        # setup of the MDA universe
        u = mda.Universe(topol,traj)
        
        if not os.path.exists(dir_name):
            try:
                os.mkdir((dir_name))
            except OSError as exc: # Guard against race condition
                if exc.errno != errno.EEXIST:
                    raise
        

        # Find if there is a protein in the membrane (True/False)
        protein = u.select_atoms("protein and not name H*")
        
      
        # Find leaflets and store them in a dictionary
        g = u.select_atoms("name P") + \
            u.select_atoms("resname ERG and name O3") +  \
            u.select_atoms("resname CHL1 and name O3")
        L =  LeafletFinder(u,g)
        upper_leaflet = L.groups(0)
        lower_leaflet = L.groups(1)
        leaflets = {"upper_leaflet":upper_leaflet,
                    "lower_leaflet":lower_leaflet}
        
        # The user selected the -all flag for all the analysis

        if args.all_modules :
            
            sys.stdout.write("\n")
            sys.stdout.write("Starting now, please stand by...")
            sys.stdout.write("\n")
            sys.stdout.write(u"\u2622")
            sys.stdout.write("\n")
            
            sys.stdout.write("Area per lipid & Thickness calculation")
        
            module_apl(u,
                       g,
                       protein,
                       dir_name,
                       apl_cutoff,
                       raw,
                       ncore)
   
            module_thickness(u,
                             g,
                             protein,
                             dir_name,
                             tck_cutoff,
                             raw,
                             ncore)

            sys.stdout.write("\n")
           
            sys.stdout.write("--------------------------------------")
            sys.stdout.write("\n")

            
            sys.stdout.write("Density maps")
            module_densmap(u,
                           leaflets,
                           dir_name)
            sys.stdout.write("\n")
            
            sys.stdout.write("--------------------------------------")
            sys.stdout.write("\n")
            
            if protein:
                # add enrichment analysis with a protein
                
                sys.stdout.write("Enrichment")
                module_enrichment(u,
                                  g,
                                  leaflets,
                                  dir_name)
                sys.stdout.write("\n")
                
                sys.stdout.write("--------------------------------------")
                sys.stdout.write("\n")



            sys.stdout.write("Diffusion")
            
            module_movements(u,
                             leaflets,
                             dir_name)
            sys.stdout.write("\n")
            
            sys.stdout.write("--------------------------------------")
            sys.stdout.write("\n")

            
            sys.stdout.write("Order Parameter")
            module_order_parameter(u,
                                   g,
                                   dir_name
                                   )
            sys.stdout.write("\n")
            
            sys.stdout.write("--------------------------------------")
            sys.stdout.write("\n")
        
        else:
            sys.stdout.write("Starting now. please stand by")
            sys.stdout.write("\n")
            sys.stdout.write(u"\u2622")
            sys.stdout.write("\n")

            if args.mod_tck : 
                module_thickness(u,
                                 g,
                                 protein,
                                 dir_name,
                                 tck_cutoff,
                                 raw,
                                 ncore)

            if args.mod_apl : 
                module_apl(u,
                           g,
                           protein,
                           dir_name,
                           apl_cutoff,
                           raw,
                           ncore)

            if args.mod_maps :
                module_densmap(u,
                               leaflets,
                               dir_name)
           
            if args.enrichment and protein:
                # add enrichment analysis with a protein
                # do it if there is also the flag for the 
                # prot
                module_enrichment(u,
                                  g,
                                  leaflets,
                                  dir_name)

     
            if args.mod_mov :
                module_movements(u,
                                 leaflets,
                                 dir_name)

            if args.mod_ord :
                module_order_parameter(u,
                                       g,
                                       dir_name)
         
        if args.clean :
            cleaning_all()
            
                                                           
       
if __name__ == "__main__":
    main()
