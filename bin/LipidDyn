#!/usr/bin/env python


# Copyright (C) 2019, Simone Scrima <simonescrima@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program. If not, see <http://www.gnu.org/licenses/>.


import time
import errno
import subprocess
import sys
import os
import os.path as path
import argparse
import shutil
from pathlib import Path
import glob
from progressbar import ProgressBar
import numpy as np
import logging

#Import the classes and functions from the utils
from LipidDyn.core import *

# Import pkg management library
import pkg_resources

#Import MDanalysis
import MDAnalysis as mda
from MDAnalysis.analysis.leaflet import LeafletFinder




_start_time = time.time()

def tic():
    global _start_time 
    _start_time = time.time()


def tac():
    t_sec = round(time.time() - _start_time)
    (t_min, t_sec) = divmod(t_sec,60)
    (t_hour,t_min) = divmod(t_min,60) 
    print('Time passed: {}hour:{}min:{}sec'.format(t_hour,t_min,t_sec))




def fatslim_analysis(trajectory_file,
                     topology_file,
                     index_headgroups,
                     directory_name,
                     apl_cutoff,
                     tck_cutoff,
                     raw,
                     ncore
                     ):
        
    """Fuction consisting of fatslim analysis 
    1) Thickness (raw +xvg)
    2) APL (raw+xvg)

    Parameters
    ----------
    trajectory_file : str
            Name of the processed .xtc file.
    topology_file : str 
            Name of the last producte .gro file.
    index_headgroups : str
            Filename of the index containing all the headgroups
    directory_name : str
            Name of the output folder
    apl_cutoff : float
            Number representing the cut-off for the APL
    tck_cutoff : float
            Number representing the cut-off for the thickness
    raw : True/False
            Value to include or not the raw output
    ncore : int
            Number of cores for parallelization             
    """


    
    # Output directory
    analysis_fatlism = os.path.abspath(directory_name + '/Fatslim/')
    if not os.path.exists(analysis_fatlism):
        try:
            os.mkdir((analysis_fatlism))
            os.mkdir((analysis_fatlism +'/fatslim_apl'))
            os.mkdir((analysis_fatlism + '/fatslim_thickness'))
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise

    
    # Begins of the fatslim analysis 
    fatslim = FatslimCommands(trajectory_file,
                              topology_file,
                              index_headgroups,
                              ncore,
                              apl_cutoff,
                              tck_cutoff)
    # progress bar
    pbar = ProgressBar().start()
    
    if raw : # if the user required the raw data
        step = 4
        pbar.update((1/step)*100) # current step/total steps * 100
        fatslim.raw_AreaPerLipid(out_file = analysis_fatlism +
                                 '/fatslim_apl/raw_apl.csv')  
        
        pbar.update((2/step)*100)  
        fatslim.raw_thickness(out_file = analysis_fatlism + \
                              '/fatslim_thickness/raw_thickness.csv'
                              )    

        pbar.update((3/step)*100)
        fatslim.thickness(out_file = analysis_fatlism +'/thickness.xvg'
                     )

        pbar.update((4/step)*100)
        fatslim.AreaPerLipid(out_file = analysis_fatlism + '/apl.xvg')
    else: 
        step = 2
        pbar.update((1/step)*100)
        fatslim.thickness(out_file = analysis_fatlism +'/thickness.xvg'
                     )

        pbar.update((2/step)*100)
        fatslim.AreaPerLipid(out_file = analysis_fatlism + '/apl.xvg')

    pbar.finish()
   

def densmaps_analysis(universe,
                      leaflets,
                      ncore,
                      directory_name):

    """
    Parameters
    -------------
    universe : class 
        MDAnalysis universe class
    leaflets : dict 
        Dictionary with MDAnalysis AtomGroup as keys of all
        the lipid residues in upper and lower leaflet. 
        Obtained using LeafletFinder class in MDAnalysis
    ncore : int
        Number of cores for parallelization        
    directory_name : str
        Name of the output folder
    """

    # output directory
    folder = os.path.abspath(directory_name +'/2D_maps/')
    if not os.path.exists(folder):
        try:
            os.mkdir((folder))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise
    
    # progress bar
    pbar = ProgressBar().start()
    total_step = 2
    step = 1 
    u = universe
    for leaflet in leaflets:
        # compute density maps for each leaflet
        grid = dmap_multiprocessing(u,
                                    leaflets[leaflet].residues.atoms,
                                    ncore)
        # output file
        np.savetxt(folder+"/"+leaflet+"_2dmap.dat",
                   grid,
                   delimiter='\t',fmt='%1.4f') 
        pbar.update((step/total_step)*100) # update status
        step += 1
    pbar.finish()
  

def enrichment_analysis(universe,
                        selection,
                        ncore,
                        directory_name):
    """
    Parameters
    -------------
    universe : class 
        MDAnalysis universe class
    selection : dict 
        MDAnalysis AtomGroup selection of all the
        lipid residue constituting the lipid bilayer
    ncore : int
        Number of cores for parallelization        
    directory_name : str
        Name of the output folder
    """

    # output directory
    folder = os.path.abspath(directory_name +'/Enrichment/')
    if not os.path.exists(folder):
        try:
            os.mkdir((folder))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise
   
    pbar = ProgressBar().start()
    total_step = 3
    d = {} # dictionary to store all the arrays for the dmaps
    # get composition of the membrane and density map of all membrane
    d["membrane"] = dmap_multiprocessing(universe,
                                         selection.residues.atoms,ncore) 
    membrane = np.unique(selection.residues.resnames)
    
    # add protein to dictionary of arrays
    protein = universe.select_atoms("protein")
    d["protein"]= dmap_multiprocessing(universe,
                                       protein,
                                       ncore)
   

    # add all the different lipid residues
    for lipid in membrane:
        # select all the lipid residues in that leaflet and add to dict
        sel = universe.select_atoms("resname " + lipid)
        d[lipid] = dmap_multiprocessing(universe,
                                        sel,
                                        ncore)

    pbar.update((1/3)*100)
    
    sum_densmap = []
    d1 = {}
    for key in d:
        # ignore all the membrane and the protein
        if key =="membrane" or key == "protein": 
            continue
        # normalize dividing single lipids by the membrane
        array = np.divide(d[key],
                      d["membrane"],
                      out=np.zeros_like(d[key]),
                      where=d["membrane"]!=0)   
        d1[key] = array
        sum_densmap.append(array) # store in densmap
    
    pbar.update((2/3)*100)

    # sum all the normalized density maps to have sum_denmaps 
    # and substract the protein array to the sum_densmap
    sum_densmap = np.sum(sum_densmap,axis=0) - d["protein"]

    for key in d1:
        array = np.divide(d1[key],
                      sum_densmap,
                      out=np.zeros_like(d1[key]),
                      where=sum_densmap!=0) # normalize  ignoring 0s  
        #d1[key] = array
        # substitute the first column and rows with their original values
        array[:,0] = d[key][:,0] 
        array[0,:] = d[key][0,:]
        np.savetxt(folder+"/"+key+"_enrich.dat",
                   array,
                   delimiter='\t',
                   fmt='%1.4f') 
    pbar.update((3/3)*100)
    pbar.finish()



def movements_analysis(universe,
                       leaflets,
                       directory_name):
         
    # Creates different folder in which the output is stored

    """From the imported module uses these function to extract the 
    trajectories associated with each lipids of both upper and lower 
    leaflet

    Parameters
    ----------
    universe : obj
            Universe object from MDAnalysis library
    leaflets : dict
        Dictionary with MDAnalysis AtomGroup as keys of all
        the lipid residues in upper and lower leaflet. 
        Obtained using LeafletFinder class in MDAnalysis
    directory_name : str
            Name of the output folder
    """

    # output directory
    analysis_traj = os.path.abspath(directory_name + "/Diffusion_movements/")
    if not os.path.exists(analysis_traj):
        try:
            os.mkdir((analysis_traj))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise
    
    # progress bar
    pbar = ProgressBar().start()
    total_step = len(leaflets["upper_leaflet"].residues)*2
    step = 1 

    # iterate through the dictionary
    for leaflet in leaflets:
        if leaflet == "upper_leaflet": 
            filename = "Upper_leaflet_coordinates.dat"
        else:
            filename = "Lower_leaflet_coordinates.dat"

        # create outputfile in the directory
        with open(analysis_traj+'/'+filename,"w") as g:
            # iterate through the residues contained in the leaflet
            for residue in leaflets[leaflet].residues:
                g.write("> " + str(residue).strip("<>").replace(",","")+"\n")
                # for every frame in the trajectory

                for ts in universe.trajectory: 
                    # extract x and y coordinate of the center of mass
                    g.write(np.array2string(
                                residue.atoms.center_of_mass()[0:2]/10,\
                                precision=3, separator='\t').strip("[]")+"\n") 
                pbar.update((step/total_step)*100)
                step += 1
    pbar.finish()




def order_par_analysis(trajectory_file,
                       topology_file,
                       directory_name
                       ):
    
    """
    Parameters
    ----------
    trajectory_file : str
            Name of the processed .xtc file. 
    topology_file : str 
            Name of the last producte .gro file.
    directory_name : str
            Name of the output folder
    """
    
    
    # Creates different folder in which the output is stored

    order_folder = directory_name + '/Order_Parameter/'

    if not os.path.exists(order_folder):
        try:
            os.mkdir((order_folder))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise


    # retrieve def file for the op in the package folder
    dirs =  pkg_resources.resource_listdir('LipidDyn','/definitions_files/')
    
    pbar = ProgressBar().start()
    total_step = len(dirs)
    step = 1 
    for def_file in dirs:
        
        # get the lipid name
        lipid_name = def_file.split('.')[0]
        # retrieve the def files from the package
        defi = pkg_resources.resource_string('LipidDyn','/definitions_files/'+
                                              def_file)
        defi = defi.decode("utf-8").split('\n') # decode the strings from bytes
        defi = list(filter(lambda x: x != '', defi)) # filter empty strings
        ordPars = parse_op_input(defi)

        read_trajs_calc_OPs(ordPars,
                            topology_file,
                            [trajectory_file]
                            )

        for op in ordPars.values():
            (op.avg, op.std, op.stem) = op.get_avg_std_stem_OP
        
     
        # writes the output file in  file 
        try:
            with open('Order_Parameter_'+ lipid_name +'.csv',"w") as f:
                f.write("{},{},{},{},{},{},{}  \n".format(
                'OP_name','resname','atom1','atom2','OP_mean','OP_stddev','OP_stem'))
                for op in ordPars.values():
                    # output in csv file format comma separated
                    f.write( 
                        "{},{},{},{},{: 2.5f},{: 2.5f},{: 2.5f} \n".format(
                              op.name, op.resname, op.atAname,
                              op.atBname,op.avg, op.std, op.stem)
                           )
        except:
            logging.warning("Problem writing the main outputfile")
        

        with open('Order_Parameter_'+ lipid_name +'.csv','r') as g :
            if "nan" in g.read():
                os.remove('Order_Parameter_'+ lipid_name +'.csv')
            else:
                shutil.move('Order_Parameter_'+ lipid_name +'.csv',
                             order_folder) 
        
        pbar.update((step/total_step)*100)
        step += 1
    pbar.finish()

         
def clean():

    # Clean all the temporary files which were created 
    os.remove('index_headgroups.ndx')
    os.remove('true_bilayer.ndx')

    


def main():

    description= 'LipidDyn pipeline for calculating different parameters' \
                 'of a lipid membrane Molecular Dynamics simulation'

    usage = 'LypidDyn -t ["".xtc/trr] -f ["".gro/tpr] -all [True/False] ' \
            '-c -fatslim -2d -mov -ordpar -d [directory name] -raw[True/False]'
             

    parser = argparse.ArgumentParser(description=description, usage=usage)

    parser.add_argument('-t',
                        '--trajectory',
                        dest='trajectory',
                        type=str,
                        required=True,
                        metavar='',
                        help='Trajectory files [<.xtc/.trr/>] ',
                        )

    parser.add_argument('-f',
                        '--topology',
                        dest='topology',
                        type=str,
                        required=True,
                        metavar='',
                        help='Molecular topology file [.gro/.tpr]',
                        )


    parser.add_argument('-d',
                        '--dir_name',
                        default = 'Analysis',
                        dest='directory',
                        type=str,
                        required=False,
                        metavar='',
                        help='The directory name for outputs of the pipeline',
                        )

    parser.add_argument('-c',
                        '--clean',
                        action='store_true',
                        dest='clean',
                        required = False,
                        help='Clean all the temporary files '
                        )

    parser.add_argument('-all',
                        '--all',
                        dest='all_modules',
                        action='store_true',
                        required = False,
                        help='Execute all module of the pipeline'
                        )

    parser.add_argument('-fatslim',
                        '--fatslim',
                        action='store_true',
                        dest='mod_fat',
                        required = False,
                        help='Execute only the fatslim module of the pipeline'
                        )

    parser.add_argument('-apl_cutoff',
                        '--apl-cutoff',
                        default= 3.0,
                        dest='apl_cutoff',
                        required = False,
                        help='Cutoff distance (in nm) used to approximate \
                              planar region (default: 3.0)'
                        )

    parser.add_argument('-thickness_cutoff',
                        '--thickness-cutoff',
                        default= 6.0,
                        dest='tck_cutoff',
                        required = False,
                        help='Cutoff distance (in nm) used to identify \
                              inter-leaflet neighbors (default: 6.0)'
                        )

    parser.add_argument('-2d',
                        '--2d_maps',
                        action='store_true',
                        dest='mod_maps', 
                        required = False,
                        help='Execute only the density maps module of the \
                              pipeline'
                                                )

    parser.add_argument('-mov',
                        '--movements',
                        action='store_true',
                        dest='mod_mov',
                        required = False,
                        help='Execute only the movement module of the \
                              pipeline'
                       )

    parser.add_argument('-ordpar',
                        '--order_parameter',
                        action='store_true',
                        dest='mod_ord',
                        required = False,
                        help='Execute only the order parameter module of \
                              the pipeline'
                        )

    parser.add_argument('-enr',
                        '--enrichment',
                        action='store_true',
                        dest='enrichment',
                        required = False,
                        help='Execute only the enrichment analysis module \
                              of the pipeline'
                       )

    parser.add_argument('-prot',
                        '--protein',
                        action='store_true',
                        dest='prot',
                        required = False,
                        help='Specify if a protein is embedded \
                              in the membrane'
                       )

    parser.add_argument('-ncore',
                        '--mpi',
                        nargs ='?',
                        default = 2,
                        dest='mpi',
                        help='Specify on how many cores to use for \
                              parallelization'
                       )

    parser.add_argument('-raw',
                        '--raw_data',
                        action='store_true',
                        dest='raw',
                        required = False,
                        help='Get the raw value of thickness and apl for \
                              each frame'
                       )




    args = parser.parse_args()

    # Setup log module
    logging.basicConfig(filename='LipidDynRun.log',
    	                level=logging.INFO,
    	                format='%(asctime)s:%(levelname)s:%(message)s')

    # Define Flags
    traj = os.path.abspath(args.trajectory)
    topol = os.path.abspath(args.topology)
    dir_name = args.directory
    ncore = int(args.mpi)
    cleaning = args.clean
    apl_cutoff = float(args.apl_cutoff)
    tck_cutoff = float(args.tck_cutoff)
    raw = args.raw
    
    
    starting_directory = os.getcwd()

    # setup of the MDA universe
    u = mda.Universe(topol,traj)
    
    if not os.path.exists(dir_name):
        try:
            os.mkdir((dir_name))
        except OSError as exc: # Guard against race condition
            if exc.errno != errno.EEXIST:
                raise

    # Means a protein is embedded in the bilayer
    if args.prot :
        # index for the fatslim analysis
        # P is for all phopholipids 
        # resname CHOL to check for cholesterol
        # resname ERG to check for ergosterol
        g = u.select_atoms("name P") + \
            u.select_atoms("resname ERG and name O3") +  \
            u.select_atoms("resname CHL1 and name O3")
        p = u.select_atoms("protein and not name H*")

        with mda.selections.gromacs.SelectionWriter(
                                        'index_headgroups.ndx',
                                         mode='a') as ndx:
            ndx.write(g, name="headgroups", frame=0)
            ndx.write(p, name="protein", frame=0)

    else:
        
        # index for the fatslim analysis
        # P is for all phopholipids 
        # resname CHOL to check for cholesterol
        # resname ERG to check for ergosterol
        g = u.select_atoms("name P") + \
            u.select_atoms("resname ERG and name O3") +  \
            u.select_atoms("resname CHL1 and name O3")
        
        with mda.selections.gromacs.SelectionWriter(
                                        'index_headgroups.ndx',
                                         mode='w') as ndx:
            ndx.write(g, name="headgroups", frame=0)
  
    # Find leaflets and store them in a dictionary
    L =  LeafletFinder(u,g)
    upper_leaflet = L.groups(0)
    lower_leaflet = L.groups(1)
    leaflets = {"upper_leaflet":upper_leaflet,
                "lower_leaflet":lower_leaflet}
  
    # index file of headgroups
    index_headgroups = starting_directory + \
                       '/index_headgroups.ndx'



    # Create an index file in which the different layers of the membrane
    # are listed 

    with mda.selections.gromacs.SelectionWriter('true_bilayer.ndx',
                                                 mode='w') as ndx:
            ndx.write(upper_leaflet, name="upper_leaflet")
            ndx.write(lower_leaflet, name="lower_leaflet")
    
    
    # The user selected the -all flag for all the analysis

    if args.all_modules :
        
   
        logging.info("Starting now with the calculation, please stand by...")
        logging.info(u"\u2622")
      
    
        logging.info("Analysis: Area per lipid & Thickness calculation")
        fatslim_analysis(traj,
                         topol,
                         index_headgroups,
                         dir_name,
                         apl_cutoff,
                         tck_cutoff,
                         raw,
                         ncore
                         )
        logging.info("--------------------------------------")
      

        logging.info("Analysis: Density maps")
        densmaps_analysis(u,
                          leaflets,
                          ncore,
                          dir_name)
        logging.info("--------------------------------------")
     
        if args.prot:
            # add enrichment analysis with a protein
            logging.info("Analysis: Enrichment Analysis")
            enrichment_analysis(u,
                                g,
                                ncore,
                                dir_name)
            logging.info("--------------------------------------")
            



        logging.info("Analysis: Diffusion movements")
        movements_analysis(u,
                           leaflets,
                           dir_name)
        logging.info("--------------------------------------")
       

        logging.info("Analysis: Order Parameter")
        order_par_analysis(traj,
                           topol,
                           dir_name
                               )
        logging.info("--------------------------------------")
     
    
    else:
        logging.info("Starting now with the calculation, please stand by")
        logging.info(u"\u2622")
   

        if args.mod_fat : 

            logging.info("Analysis: Area per lipid & Thickness calculation")
            fatslim_analysis(traj,
                             topol,
                             index_headgroups,
                             dir_name,
                             apl_cutoff,
                             tck_cutoff,
                             raw,
                             ncore)
            logging.info("--------------------------------------")

        if args.mod_maps :
            
            logging.info("Analysis: Density maps")
            densmaps_analysis(u,
                              leaflets,
                              ncore,
                              dir_name)
            logging.info("--------------------------------------")
       
        if args.enrichment and args.prot:
            # add enrichment analysis with a protein
            # do it if there is also the flag for the 
            # prot
            logging.info("Analysis: Enrichment Analysis")
            enrichment_analysis(u,
                                g,
                                ncore,
                                dir_name)
            logging.info("--------------------------------------")

 
        if args.mod_mov :
            
            logging.info("Analysis: Diffusion movements")
            movements_analysis(u,
                               leaflets,
                               dir_name)
            logging.info("--------------------------------------")

        if args.mod_ord :

            logging.info("Analysis: Order Parameter")
            order_par_analysis(traj,
                               topol,
                               dir_name)
            logging.info("--------------------------------------")
     
    if args.clean:
        clean()

if __name__ == "__main__":
    main()
